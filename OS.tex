\documentclass{OSreport}


\stclass{计算机2401}
\stuid{2244113131}
\stname{王豪源}
\begin{document}
% 生成封面
\makecover

% 生成目录
\tableofcontents
\newpage

% 正文开始

\section{OpenEuler系统环境实验}

\subsection{实验目的}

\begin{enumerate}
    \item 熟悉 Linux 操作系统的基本环境和操作方法，通过运行系统命令查看系统基本信息以了解系统；
    
    \item 编写并运行简单的进程调度相关程序，体会进程调度、进程间变量的管理等机制在操作系统实际运行中的作用。
\end{enumerate}

\subsection{实验内容}
\begin{enumerate}
    \item 熟悉操作命令、编辑、编译、运行程序。完成图 1-1 程序的运行验证，多运行几次程序观察结果；去除 wait 后再观察结果并进行理论分析。
    
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{./tex_picture/lab1/1.png}
    \caption{图1-1}
    \label{fig:my_image}
\end{figure}

    \item 扩展图 1-1 的程序：
    \begin{enumerate}
        \item 添加一个全局变量并在父进程和子进程中对这个变量做不同操作，输出
        操作结果并解释；
        \item 在return 前增加对全局变量的操作并输出结果，观察并解释；
        \item 修改程序体会在子进程中调用 system 函数和在子进程中调用 exec 族函数；   
    \end{enumerate}
\end{enumerate}

\subsection{实验思想}
\begin{enumerate}
    \item 进程：进程是计算机科学中的一个重要概念，它是操作系统中的基本执
    行单位。进程代表着一个正在执行的程序实例，它包括了程序的代码、数据和执
    行状态等信息。操作系统通过进程管理来实现对计算机资源的有效分配和控制；
    \item PID：PID 是进程标识符（Process Identifier）的缩写，它是用来唯
    一标识一个操作系统中的进程的数值。每个正在运行或已经终止的进程都会被分
    配一个唯一的 PID，这个标识符可以用来在操作系统内部识别和管理进程；
    \item fork()函数：fork() 是一个在类 Unix 操作系统中常见的系统调用，
    用于创建一个新的进程，新进程是原进程（父进程）的副本。新进程被称为子进
    程，它与父进程共享很多资源，但也有一些独立的属性。fork() 被用于实现多
    进程编程，常见于操作系统和并发编程中。函数返回一个整数，如果返回值为负
    数，则表示创建进程失败。如果返回值为 0，表示当前正在执行的代码是在子进
    程中。如果返回值大于 0，表示当前正在执行的代码是在父进程中，返回值是子
    进程的 PID。调用 fork() 函数时，操作系统会创建一个新的进程，该进程是调
    用进程的一个副本，称为子进程。子进程几乎与父进程相同，包括代码、数据、
    文件描述符等。但是子进程拥有自己的独立的内存空间和资源。
\end{enumerate}

\subsection{实验步骤}
本实验通过在程序中输出父、子进程的 pid，分析父子进程 pid 之间的关系，
进一步加入 wait()函数分析其作用。
\begin{enumerate}
    \item 编写并多次运行图 1-1 中代码
    \begin{figure}[htbp]
        \centering
        \includegraphics[width=0.8\textwidth]{./lab1/readme/picture/step1-1.png}
        \caption{图1-1}
        \label{fig:my_image}
    \end{figure}
    可以看到，始终是先打印子进程，再打印父进程。
    \item 删去图 1-1 代码中的 wait()函数并多次运行程序，分析运行结
    果。
    \begin{figure}[htbp]
        \centering
        \includegraphics[width=0.8\textwidth]{./lab1/readme/picture/step1-2.png}
        \caption{图1-1}
        \label{fig:my_image}
    \end{figure}
    可以发现当前情况下存在child有可能先于parent进程运行。

    原因在于wait会阻塞父进程的执行知道子进程执行完成。去除之后，父子进程并发执行，打印顺序将不确定，并会出现僵尸进程。

    可以将父进程先结束，打印子进程的ppid实验如下
    \begin{figure}[htbp]
        \centering
        \includegraphics[width=0.8\textwidth]{./lab1/readme/picture/new1.png}
        \caption{图1-1}
        \label{fig:my_image}
    \end{figure}
    
    \item 修改图 1-1 中代码，增加一个全局变量并在父子进程中对其进行不同的操作，观察并解释所做操作和输出结果。
    
    我定义了一个全局变量value，在每个进程中，先输出原始值，在输出更改后的值，对value的更改都是将他设置为当前进程的PID。

    运行结果

    \begin{figure}[htbp]
        \centering
        \includegraphics[width=0.8\textwidth]{./lab1/readme/picture/step1-3.png}
        \caption{图1-1}
        \label{fig:my_image}
    \end{figure}
    
    父进程与子进程先后交替运行，是合理的。并且通过分析，父子进程的value各自拥有一个独立的副本，每个进程对value的修改是独立的。

    在程序中打印value的地址

    运行结果
    \begin{figure}[htbp]
        \centering
        \includegraphics[width=0.8\textwidth]{./lab1/readme/picture/new2.png}
        \caption{图1-1}
        \label{fig:my_image}
    \end{figure}
    从这个结果，可以更好的理解操作系统的内存机制。

    第一，每次运行时，父子进程的value地址是相同的，这是因为在fork时，父子进程共享页表，因此地址是一样的,value的独立副本是它们采取写时复制机制，当需要对某个地址空间的值做修改时，会使该页表指向新的物理帧。

    第二，每次运行value的虚拟地址空间都是不变的，这是因为代码在编译链接阶段就已经确定好了变量的虚拟地址。   
    \item 在步骤三基础上，在 return 前增加对全局变量的操作（自行设计）并输出结果，观察并解释所做操作和输出结果
    进行的操作是对10取余，再次印证了value是独立的副本。
    \begin{figure}[htbp]
        \centering
        \includegraphics[width=0.8\textwidth]{./lab1/readme/picture/step1-4.png}
        \caption{图1-1}
        \label{fig:my_image}
    \end{figure}
    \item 步骤五： 修改图 1-1 程序，在子进程中调用 system()与 exec 族函数。 编写system_call.c 文件输出进程号 PID，编译后生成 system_call 可执行文件。在子进程中调用 system_call,观察输出结果并分析总结。
    调用system()运行结果
    \begin{figure}[htbp]
        \centering
        \includegraphics[width=0.8\textwidth]{./lab1/readme/picture/step1-5.png}
        \caption{图1-1}
        \label{fig:my_image}
    \end{figure}
    可以看到system会新建一个进程。

    调用exec族函数运行结果
    \begin{figure}[htbp]
        \centering
        \includegraphics[width=0.8\textwidth]{./lab1/readme/picture/step1-6.png}
        \caption{图1-1}
        \label{fig:my_image}
    \end{figure}

    运行结果分析，调用exec族函数，会将代码段加载进来，替换掉原来的代码段，使得原来得代码在调用exec之后的代码段是没有继续运行的。

    但exec并不会创建一个新进程，他还是原来的那个进程。

\end{enumerate}


\subsection{程序运行初值及运行结果分析}
运行结果分析如上。

\subsection{实验总结}
\begin{enumerate}
    \item 使用 system() 调用
    \begin{enumerate}
        \item 父进程PID： 父进程的有一个PID。这是该进程的唯一标识符。
        \item 子进程PID： 子进程通过 system() 调用 system_call 执行文件时，生成了一个新的进程，该新进程也有一个PID。
    \end{enumerate}
    \item 使用 exec() 调用
    \begin{enumerate}
        \item 子进程替换： 通过对旧代码的分析,exec() 函数替换了子进程的内容,这也就导致了printf没有输出出来。这个PID与父进程中显示的子进程PID一致。
        \item 进程替换： 使用 exec() 替换了子进程的内容，所以新的 system_call 运行在原子进程的上下文中，而没有创建新的进程。
        \item 控制流： 两种方法都在子进程中成功调用了 system_call，但 system() 允许子进程继续执行其他代码，而 exec() 则完全替换了子进程，使得 exec() 之后的代码不会被执行。
    \end{enumerate}
\end{enumerate}

\subsubsection{实验中的问题与解决过程}
\begin{enumerate}
    \item 刚开始不熟悉wait的基本用法，通过上网搜索资料，了解wait的工作原理，也再次加深了对僵尸进程的理解。
    \item 不了解system和exec族函数的用法，通过浏览各大技术博客，理解了system相当于命令行的用法，并新建立进程。学习了exec后缀-l，-e，-v，-p的含义，并理解了为什么加载不熟悉的程序要用-e后缀创建新的环境变量。
    \item 在用命令编译文件时，含有线程相关的源文件编译错误。学习之后了解到要手动链接到POSIX库，加上后缀-pthread解决。
    \item 在线程实验的步骤三中，exec前的线程PID以及TID无法输出。原因是printf要缓冲区刷新时才输出，用fprintf或者exec前加上fflush强制刷新缓冲区执行。
\end{enumerate}

\subsubsection{实验收获}
\begin{enumerate}
    \item 进程管理理解深化：通过这个实验，更加深入地了解了 Linux 系统中进程的创建、管理和调度。特别是通过观察 wait() 函数的行为，理解了父子进程间同步的重要性。
    \item 编程技巧提升：这个实验让我更熟悉了 C 语言的编程模式，尤其是涉及到系统级调用和进程管理的函数。对 fork(), wait(), system(), 和 exec() 等函数有了更深入的了解。
    \item 系统调用与命令行工具：实验中涉及到 system() 和 exec() 系列函数，使我了解了如何在程序中执行系统命令，以及如何用 exec() 替换当前进程的执行内容。
    \item 多进程编程模型：通过在一个程序中创建多个进程，以及管理这些进程的行为和状态，我对多进程编程有了更实际的认识和理解。
\end{enumerate}

\subsubsection{意见与建议}
\begin{enumerate}
    \item 
\end{enumerate}
\subsection{附件}

\subsubsection{附件1 程序}
在此处插入代码或说明...

\subsubsection{附件2 ReadMe}
在此处插入ReadMe内容...

\section{进程通信与内存管理}
% 根据需要添加子章节
\subsection{实验目的}
...

\section{文件系统/字符设备驱动与动态模块}
% 根据需要添加子章节
\subsection{实验目的}
...

\section{总结}
在此处填写整个课程设计的总结...

\end{document}